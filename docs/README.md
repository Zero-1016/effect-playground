# Why Effect? [번역](https://effect.website/docs/why-effect)

## 만들어진 계기

프로그래밍은 도전적입니다. 라이브러리와 앱을 구축할 때, 우리는 복잡성을 관리하고 일상을 더 쉽게 만들기 위해 많은 도구를 찾습니다. Effect는 TypeScript에서 프로그래밍에 대한 새로운 사고 방식을 제시합니다.

Effect는 더 나은 애플리케이션과 라이브러리를 구축할 수 있도록 돕는 도구들의 생태계입니다. 이를 통해 TypeScript 언어에 대해 더 많이 배우고, 타입 시스템을 사용하여 프로그램을 더 신뢰할 수 있고 유지 관리하기 쉽게 만드는 방법을 배우게 됩니다.

일반적인 TypeScript에서는 Effect 없이 함수가 성공하거나 예외를 던질 것을 가정하고 코드를 작성합니다. 다음은 간단한 나눗셈 예제입니다.

```typescript
const divide = (a: number, b: number): number => {
  if (b === 0) {
    throw new Error("Cannot divide by zero")
  }
  return a / b
}
```

타입만 봐서는 이 함수가 예외를 던질 수 있다는 사실을 전혀 알 수 없습니다. 코드를 읽어야만 알 수 있죠. 코드베이스에 함수가 하나만 있을 때는 큰 문제가 되지 않을 수 있지만, 수백 개 또는 수천 개의 함수가 있을 때는 상황이 달라집니다. 함수가 예외를 던질 수 있다는 것을 잊어버리기 쉽고, 그 예외를 처리하는 것을 놓치기 쉽습니다.

우리는 종종 가장 쉬운 방법인 try/catch 블록으로 함수를 감쌉니다. 이는 프로그램이 충돌하지 않도록 막는 좋은 첫 단계이지만, 복잡한 애플리케이션이나 라이브러리를 관리하거나 이해하는 데는 큰 도움이 되지 않습니다. 우리는 더 나은 방법을 찾을 수 있습니다.

TypeScript에서 가장 중요한 도구 중 하나는 컴파일러입니다. 컴파일러는 버그, 도메인 오류, 그리고 일반적인 복잡성에 대한 첫 번째 방어선입니다.

## Effect 패턴

Effect는 다양한 도구들의 방대한 생태계이지만, 한 가지 아이디어로 축약된다면 다음과 같습니다.

Effect의 주요 독창적 통찰은 성공 값뿐만 아니라 오류와 "컨텍스트" (이후에 자세히 설명)를 추적하기 위해 타입 시스템을 사용할 수 있다는 것입니다. 이는 위의 나눗셈 예제에서 성공 값만 추적하는 것과는 다릅니다.

다음은 Effect 패턴을 사용한 동일한 나눗셈 함수입니다.

```typescript
import { Effect } from "effect"

const divide = (a: number, b: number): Effect.Effect<number, Error, never> =>
  b === 0
    ? Effect.fail(new Error("Cannot divide by zero"))
    : Effect.succeed(a / b)
```
타입 시그니처를 보면 성공 값(숫자), 던질 수 있는 오류(Error), 함수가 필요한 컨텍스트(여기서는 없음, 즉 never)를 정확히 알 수 있습니다. 이 함수는 더 이상 예외를 던지지 않으며, 오류를 이 함수의 호출자에게 깔끔하게 전달할 수 있습니다.

이제 오류도 성공 값처럼 값이 됩니다. Effect는 오류와 성공 값을 관리하기 위한 많은 기능을 제공합니다.

또한, 컨텍스트를 추적하면 모든 것을 인수로 전달하지 않고도 함수에 추가 정보를 제공할 수 있습니다. 예를 들어, 테스트 중에 라이브 외부 서비스의 구현을 모의 객체로 바꿔도 핵심 비즈니스 로직을 변경하지 않을 수 있습니다. 컨텍스트에는 이 외에도 많은 사용 사례가 있습니다.

## Effect의 생테계

이 독창적 통찰과 다양한 도구들이 결합되어 복잡한 애플리케이션을 TypeScript로 쉽게 구축할 수 있는 풍부한 라이브러리 생태계를 만들어냈습니다. 불가능해 보였던 것들이 이제는 일상적입니다. Effect의 생태계는 빠르게 성장하고 있으며, 성장하는 목록을 Effect의 [GitHub](https://github.com/Effect-TS)에서 찾을 수 있습니다.

## 바퀴를 재발명하지 마세요

TypeScript의 애플리케이션 코드는 종종 같은 문제를 반복해서 해결합니다. 외부 서비스, 파일 시스템, 데이터베이스와 상호작용하는 등 모든 애플리케이션 개발자가 직면하는 공통적인 문제들이 있습니다. Effect는 이러한 문제들에 대한 표준화된 솔루션을 제공하는 풍부한 라이브러리 생태계를 제공합니다. 이 라이브러리들을 사용하여 애플리케이션을 구축할 수 있으며, 자신만의 라이브러리를 구축하는 데도 사용할 수 있습니다.

오류 처리, 디버깅, 추적, 비동기/프라미스, 재시도, 스트리밍, 동시성, 캐싱, 리소스 관리 등과 같은 도전 과제들을 Effect로 관리할 수 있습니다. 이 문제들을 해결하기 위해 많은 종속성을 설치하거나 여러 다른 API를 가진 다양한 종속성을 설치할 필요가 없습니다. Effect는 하나의 우산 아래에서 이러한 많은 문제들을 해결합니다.

## 실용적인 문제 해결

Effect는 Scala와 Haskell 같은 다른 언어에서 많은 영감을 받았습니다. 그러나 Effect의 목표는 실질적인 도구 키트를 제공하는 것이며, TypeScript로 애플리케이션과 라이브러리를 구축할 때 개발자가 직면하는 일상적인 문제를 해결하기 위해 많은 노력을 기울입니다.

## 즐겁게 구축하고 학습하세요

Effect를 학습하는 것은 매우 재미있습니다. Effect 생태계의 많은 개발자들이 실제 업무에서 Effect를 사용하여 문제를 해결하고 있으며, TypeScript를 가장 유용한 언어로 만들기 위해 최첨단 아이디어를 실험하고 있습니다.

Effect의 모든 측면을 한꺼번에 사용할 필요는 없으며, 해결하고 있는 문제에 가장 적합한 생태계의 일부부터 시작할 수 있습니다. Effect는 도구 키트이며, 사용 사례에 가장 적합한 부분을 선택할 수 있습니다. 그러나 코드베이스의 점점 더 많은 부분이 Effect를 사용하게 되면, 생태계의 더 많은 부분을 활용하고 싶어질 것입니다!

Effect의 개념은 처음에는 생소할 수 있으며 완전히 이해되지 않을 수 있습니다. 이는 완전히 정상입니다. 문서를 천천히 읽고 핵심 개념을 이해하려고 노력하세요. 나중에 더 고급 도구를 사용할 때 큰 도움이 될 것입니다. Effect 커뮤니티는 항상 학습과 성장을 돕기 위해 기꺼이 도와줍니다. [Discord](https://discord.gg/effect-ts)에 참여하거나 [GitHub](https://github.com/Effect-TS)에서 논의하세요! 우리는 피드백과 기여를 환영하며, Effect를 개선하기 위해 항상 노력하고 있습니다.
